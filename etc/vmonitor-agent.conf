receivers:
  hostmetrics:
    collection_interval: 60s
    scrapers:
      cpu:
      memory:
      # disk:
      # load:
      # filesystem:
      # network:
      # paging:
  
  mysql: # metrics
    endpoint: "${V_HOST}:${V_PORT}"
    username: "${V_USER}"
    password: "${V_PASS}"
    collection_interval: 60s
  
  sqlquery/statement:
    driver: mysql
    datasource: "${V_USER}:${V_PASS}@tcp(${V_HOST}:${V_PORT})/mysql"
    collection_interval: 60s
    queries:
      - sql: "SELECT `schema_name` as SCHEMA_NAME, `digest` AS `DIGEST`, `digest_text` AS DIGEST_TEXT, `count_star`, `sum_timer_wait`/1000000000 as `sum_timer_wait_ms`, `sum_rows_sent` FROM performance_schema.events_statements_summary_by_digest WHERE `digest_text` NOT LIKE 'EXPLAIN %' OR `digest_text` IS NULL LIMIT 10000;"
        logs:
          - body_column: SCHEMA_NAME

  sqlquery/wait:
    driver: mysql
    datasource: "${V_USER}:${V_PASS}@tcp(${V_HOST}:${V_PORT})/mysql"
    collection_interval: "10s"
    queries:
      - sql: 'SELECT current_schema, thread_a.thread_id, thread_a.processlist_id, thread_a.processlist_user, thread_a.processlist_host, COALESCE(statement.current_schema, thread_a.processlist_db) as SCHEMA_NAME, thread_a.processlist_command, thread_a.processlist_state, COALESCE(statement.sql_text, thread_a.PROCESSLIST_info) AS QUERY_SAMPLE_TEXT, statement.timer_start AS event_timer_start, statement.timer_end AS event_timer_end, statement.lock_time, waits_a.event_id AS event_id, waits_a.end_event_id, IF ( waits_a.thread_id IS NULL, "other", COALESCE( IF ( thread_a.processlist_state = "User sleep", "User sleep", IF ( waits_a.event_id = waits_a.end_event_id, "CPU", waits_a.event_name ) ), "CPU" ) ) AS wait_event, waits_a.operation, waits_a.timer_start AS wait_timer_start, waits_a.timer_end AS wait_timer_end, (waits_a.timer_end - waits_a.timer_start) AS wait_timer_duration, (statement.timer_end - statement.timer_start) AS event_timer_duration, waits_a.object_schema, waits_a.object_name, waits_a.index_name, waits_a.object_type, waits_a.source FROM performance_schema.threads AS thread_a LEFT JOIN performance_schema.events_waits_current AS waits_a ON waits_a.thread_id = thread_a.thread_id LEFT JOIN performance_schema.events_statements_current AS statement ON statement.thread_id = thread_a.thread_id WHERE thread_a.processlist_state IS NOT NULL AND thread_a.processlist_command != "Sleep" AND thread_a.processlist_id != CONNECTION_ID () AND thread_a.PROCESSLIST_COMMAND != "Daemon" AND ( waits_a.EVENT_NAME != "idle" OR waits_a.EVENT_NAME IS NULL ) AND ( waits_a.operation != "idle" OR waits_a.operation IS NULL ) AND ( waits_a.event_id = ( SELECT MAX(waits_b.EVENT_ID) FROM performance_schema.events_waits_current AS waits_b WHERE waits_b.thread_id = thread_a.thread_id ) OR waits_a.event_id IS NULL ) AND COALESCE(statement.sql_text, thread_a.PROCESSLIST_info) != ""'
        logs:
          - body_column: explain_not_cached

processors:
  batch:

exporters:
  kafka:
    topic: "${TOPIC}"
    protocol_version: 2.0.0
    producer:
      max_message_bytes: 5000000
    encoding: raw
    brokers:
      - hcm01-loghub01.vngcloud.vn:10092
      - hcm02-loghub01.vngcloud.vn:10092
      - hcm03-loghub01.vngcloud.vn:10092
    auth:
      tls:
        ca_file: /etc/vmonitor-agent/VNG.trust.pem
        cert_file: /etc/vmonitor-agent/user.cer.pem
        key_file: /etc/vmonitor-agent/user.key.pem
        insecure: true
        insecure_skip_verify: true
  
  vmonitor:
    endpoint: "${VMONITOR_SITE}"
    client_id: "${IAM_CLIENT_ID}"
    client_secret: "${IAM_CLIENT_SECRET}"
    iam_url: "${IAM_URL}"

    # content_encoding: gzip
    flush_interval: 3 # second(s)
    # hostname: "custom_name"
    
    metric_batch_size: 1000
    metric_buffer_limit: 150000

    logs_to_metrics:
      dimension_keys:
        - "SCHEMA_NAME"
        - "DIGEST_TEXT"
        - "DIGEST"
      value_keys:
        - "count_star"
        - "sum_rows_sent"
        - "sum_timer_wait_ms"
        # - "sum_lock_time_ms"
        # - "sum_errors"
        # - "sum_rows_affected"
        # - "sum_rows_examined"
        # - "sum_select_scan"
        # - "sum_select_full_join"
        # - "sum_no_index_used"
        # - "sum_no_good_index_used"

service:
  # https://github.com/open-telemetry/opentelemetry-collector/blob/7666eb04c30e5cfd750db9969fe507562598f0ae/config/service.go#L99-L111
  # telemetry:
    # metrics:
    #   level: none
    #   address: localhost:8888
  pipelines:
    logs/wait:
      receivers: [sqlquery/wait]
      processors: [batch]
      exporters: [kafka]
    logs/statement:
      receivers: [sqlquery/statement]
      processors: [batch]
      exporters: [vmonitor]